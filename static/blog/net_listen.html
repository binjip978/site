<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Go networking interfaces</title>
    <link rel="stylesheet" href="../styles.css">
</head>

<body>
    <section class="blog">
        <h1>Go networking interfaces</h1>

        <p> Go provides a high-level networking API and does not directly expose socket-level functionality through the net package. However, you can access socket-level operations via the syscall package if necessary. Instead, Go offers primitives like net.Dial and net.Listen that return a net.Conn interface, which provides generic Read and Write methods whose behaviour depends on the underlying connection.

        <p>Example of a simple UDP server, that try to respond to client:

        <pre>
package main

import (
    "fmt"
    "log"
    "net"
)

func main() {
    conn, err := net.ListenUDP("udp", &net.UDPAddr{Port: 1234})
    if err != nil {
        panic(err)
    }

    b := make([]byte, 1024)
    for {
        n, err := conn.Read(b)
        if err != nil {
            log.Println(err)
        }

        fmt.Printf("Received: %s\n", b[:n])

        n, err = conn.Write([]byte("Hello from server"))
        if err != nil {
            log.Println(n, err)
        }
    }
}
</pre>

        <p> If we connect to the server using netcat we will be able to read data from a client, but it will fail to
            send "Hello from server".

        <pre>
nc -u 127.0.0.1 1234
hello

./server
Received: hello
2024/01/14 09:40:24 0 write udp [::]:1234: write: destination address required
</pre>

        <p> The error message "EDESTADDRREQ The socket is not connection-mode, and no peer address is set." indicates that you are trying to send data to a client using a UDP socket without first determining the client's address. To resolve this issue, you should use the UDPConn's ReadFrom and WriteTo methods to read the client's address and then send your response to that address. The problem here is that net.Conn interface or net.UDPConn have Write method that not really works in UDP case. 

        <pre>
package main

import (
    "fmt"
    "log"
    "net"
)

func main() {
    conn, err := net.ListenUDP("udp", &net.UDPAddr{Port: 1234})
    if err != nil {
        panic(err)
    }

    b := make([]byte, 1024)
    for {
        n, addr, err := conn.ReadFromUDP(b)
        if err != nil {
            log.Println(err)
        }

        fmt.Printf("Received: %s\n", b[:n])

        n, err = conn.WriteToUDP([]byte("Hello from server"), addr)
        if err != nil {
            log.Println(n, err)
        }
    }
}
</pre>

        <pre>
nc -u 127.0.0.1 1234
hello
Hello from server^C

./server
Received: hello    
</pre>

        <p>Actually in Linux it's possible to create a connected socket over an unconnected one <a
                href="https://blog.cloudflare.com/everything-you-ever-wanted-to-know-about-udp-sockets-but-were-afraid-to-ask-part-1">everything-you-ever-wanted-to-know-about-udp-sockets-but-were-afraid-to-ask-part-1</a>,
            but it's quite hacky and require reaching syscall package.

        <p>But the problem we no longer have generic net.Conn interface and Read/Write works only in one way. That sad, because Read/Write methods is very useful in Go.

    </section>

</body>